{
    "data_structures": {
        "array": "An array is a collection of elements stored at contiguous memory locations. It provides constant-time access using indices.",
        "linked list": "A linked list is a linear data structure where elements are stored in nodes. Each node contains data and a reference to the next node.",
        "stack": "A stack is a LIFO (Last In First Out) data structure that supports push and pop operations.",
        "queue": "A queue is a FIFO (First In First Out) data structure that supports enqueue and dequeue operations.",
        "binary tree": "A binary tree is a hierarchical data structure where each node has at most two children.",
        "hash table": "A hash table is a data structure that maps keys to values using a hash function."
    },
    "algorithms": {
        "bubble sort": "Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.",
        "quick sort": "Quick sort is a divide-and-conquer algorithm that selects a pivot element and partitions the array around the pivot.",
        "binary search": "Binary search is an efficient algorithm for finding an item from a sorted list of items by repeatedly dividing the search interval in half.",
        "merge sort": "Merge sort is a divide-and-conquer sorting algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves."
    },
    "time_complexities": {
        "array": {
            "access": "O(1)",
            "insert": "O(n)",
            "delete": "O(n)",
            "search": "O(n), O(log n) if sorted"
        },
        "linked list": {
            "insert_front": "O(1)",
            "insert_end": "O(1) with tail pointer, O(n) without",
            "delete": "O(1) if node given, O(n) to find node",
            "search": "O(n)"
        },
        "stack": {
            "push": "O(1)",
            "pop": "O(1)"
        },
        "queue": {
            "enqueue": "O(1)",
            "dequeue": "O(1)"
        },
        "bubble sort": {
            "time": "O(n²)"
        },
        "quick sort": {
            "time": "O(n log n) average, O(n²) worst case"
        },
        "binary search": {
            "time": "O(log n)"
        },
        "merge sort": {
            "time": "O(n log n)"
        }
    },
    "space_complexities": {
        "array": "O(n)",
        "linked list": "O(n)",
        "stack": "O(n)",
        "queue": "O(n)",
        "bubble sort": "O(1)",
        "quick sort": "O(log n) average, O(n) worst case",
        "binary search": "O(1)",
        "merge sort": "O(n)"
    },
    "code_examples": {
        "linked list": "struct Node {\n    int data;\n    Node* next;\n    Node(int val) : data(val), next(nullptr) {}\n};",
        "binary search": "int binarySearch(int arr[], int left, int right, int target) {\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) return mid;\n        if (arr[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}"
    },
    "keyword_mappings": {
        "sort": ["bubble sort", "quick sort", "merge sort"],
        "search": ["binary search", "linear search"],
        "tree": ["binary tree", "binary search tree"],
        "complexity": ["time complexity", "space complexity"]
    }
  }